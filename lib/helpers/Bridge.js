/**
 * Main Bridge Class that will be used for contract interactions,
 * It has the logic for synchronizing state amongst a set of contracts
 * Follows the builder pattern for idiomatic use
 * Example -
 * const bridge = new Bridge()
 *                          .setSourceContract()
 *                          .setTargetContract()
 *                          .setSourceEvents()
 *                          .setTargetEvents()
 *                          .setSourceConfirmations()
 *                          .setTargetConfirmations()
 *                          .setSyncInterval()
 *                          .setHealthRatio()
 *                          .setup()
 */
class Bridge {
  constructor(opts) {
    Object.assign(this, opts || {});
    this.txQueue = new Map();
  }

  /**
   * Set the source contract
   * @param {Contract} contract
   * @returns {Bridge}
   */
  setSourceContract(contract) {
    this.sourceContract = contract;
    return this;
  }

  /**
   * Set the source events
   * @param {array} events
   * @returns {Bridge}
   */
  setSourceEvents(events) {
    this.sourceEvents = events;
    return this;
  }

  /**
   * Set the target events
   * @param {array} events
   * @returns {Bridge}
   */
  setTargetEvents(events) {
    this.targetEvents = events;
    return this;
  }

  /**
   * Set the target contract
   * @param {Contract} contract
   * @returns {Bridge}
   */
  setTargetContract(contract) {
    this.targetContract = contract;
    return this;
  }

  /**
   * Set the block confirmations on the source network
   * @param {Number} n
   * @returns {Bridge}
   */
  setSourceConfirmations(n = 6) {
    this.sourceConfirmations = n;
    return this;
  }

  /**
   * Set the block confirmations on the target network
   * @param {Number} n
   * @returns {Bridge}
   */
  setTargetConfirmations(n = 6) {
    this.targetConfirmations = n;
    return this;
  }

  /**
   * Set the interval at which both networks should sync
   * @param {seconds} n
   * @returns {Bridge}
   */
  setSyncInterval(n = 600) {
    this.syncInterval = n;
    return this;
  }

  /**
   * Set the health ratio, i.e sourceRate/exchangeRate
   * @param {Float} n
   * @returns {Bridge}
   */
  setHealthRatio(n = 0.95) {
    this.healthRatio = n;
    return this;
  }

  /**
   * Sets up the event handlers, and any other async tasks
   * Meant to be used last in the builder pattern
   */
  setup = async () => {
    await this.setupEventListeners();
  };

  /**
   * Setup event listeners for source and target events
   */
  setupEventListeners = async () => {
    if (this.sourceEvents.length >= 1) {
      this.sourceEvents.forEach((eventName) => {
        this.sourceContract.on(eventName, async () => await this.sourceEventHandler);
      });
    }
    if (this.targetEvents.length >= 1) {
      this.targetEvents.forEach((eventName) => {
        this.targetContract.on(eventName, async () => await this.targetEventHandler);
      });
    }
  };

  /**
   * This function is called anytime source event occurs
   * Note - This function can be modified in the future to set the pending transactions
   *        to a caching service/database such as redis/mysql etc 
   * @param  {...any} eventObj
   */
  sourceEventHandler = async (...eventObj) => {
    if (!this.txQueue.has('source')) {
      this.txQueue.set('source', [eventObj])
    } else {
      this.txQueue.get('source').push(eventObj)
    }
  };

  /**
   * This function is aclled anytime target event occurs
   * Note - This function can be modified in the future to set the pending transactions
   *        to a caching service/database such as redis/mysql etc 
   * @param  {...any} eventObj
   */
  targetEventHandler = async (...eventObj) => {
    if (!this.txQueue.has('target')) {
      this.txQueue.set('target', [eventObj])
    } else {
      this.txQueue.get('target').push(eventObj)
    }
  };

  /**
   * Gets the pending transactions
   * @returns {Object} object of 2 arrays, pending source and target transactions
   * Note - This function can be modified in the future to fetch the pending transactions
   *        from a caching service/database such as redis/mysql etc 
   */
  getPendingTransactions = async () => {
    return {
      source: this.txQueue.has('source') ? this.txQueue.get('source') : 0,
      target: this.txQueue.has('target') ? this.txQueue.get('target') : 0,
    }
  }
}

/**
 * Coerces the getContracts return value into a bridge array
 * @param {Object} configMap config map from the output generated by the getContracts function
 * @returns {Array<Bridge>}
 */
const coerceToBridge = (configMap) => {
  const bridges = [];
  for (const v of configMap.values()) {
    bridges.push(
      new Bridge()
        .setSourceContract(v.sourceContract.contract)
        .setTargetContract(v.targetContract.contract)
        .setSourceEvents(v.sourceContract.eventsToWatch)
        .setTargetEvents(v.targetContract.eventsToWatch)
        .setSourceConfirmations(v.sourceContract.confirmations)
        .setTargetConfirmations(v.targetContract.confirmations)
        .setSyncInterval(v.interval)
        .setHealthRatio(v.healthRatio)
    );
  }
  return bridges;
};

module.exports = { Bridge, coerceToBridge };
